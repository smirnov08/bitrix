# Подключение системы кэширования в Bitrix d7
Чтобы использовать тип кэширования, который не поддерживается системой или использовать свой тип кэширования, нужно задать массив настроек в ключе `type`:
```php
'cache' => 
  array (
    'value' => 
    array (
      'type' => array(
        'class_name' => '', //Класс реализующий интерфейс ICacheEngine
        'required_file' => '', //Файл относительно папки local или bitrix
        'required_remote_file' => '', //Абсолютный путь к файлу
        'extension' => '' //Подключение через extension_loaded (имя расширения)
      ),
    ),
    'readonly' => false,
  ),
```
- `readonly` - ключ означает, что нельзя изменить значение через API.
- `class_name` - класс реализующий интерфейс `ICacheEngine` (вместе с namespace).
- `required_file` - Файл относительно папки `local` или `bitrix` (который нужно подключить для реализации технологии кэша).
- `required_remote_file` - Абсолютный путь к файлу (Если файл находится вне папки `local` или `bitrix`).
- `extension` - Расширение php, которое должно быть включено.
 
## Интерфейс `ICacheEngine`
Первое и необходимое, что нужно реализовать это класс работы с кэшем, который имплементирует интерфейс `ICacheEngine`
```php
namespace Bitrix\Main\Data;

interface ICacheEngine
{
	public function isAvailable(); 
	public function clean($baseDir, $initDir = false, $filename = false);
	public function read(&$arAllVars, $baseDir, $initDir, $filename, $TTL);
	public function write($arAllVars, $baseDir, $initDir, $filename, $TTL);
	public function isCacheExpired($path);
}

/*Необязательно, но можно имплементировать, если будет необходимо. Все типы кэширования битрикс из коробки 
имплементируют этот интерфейс*/
interface ICacheEngineStat
{
	public function getReadBytes();
	public function getWrittenBytes();
	public function getCachePath();
}
```
### Хранение кэша в сессии пользователя `CacheEngineSession`.
В качестве примера, реализуем класс для хранения кэша в сессии пользователя. Не рекомендуется использовать данных тип кэширования, особенно на платформе битрикс, приведено в качестве ознакомления и понимания основных принципов.
```php

use \Bitrix\Main\Data\ICacheEngine;
use \Bitrix\Main\Data\ICacheEngineStat;
use \Bitrix\Main\Config\Configuration;

class CacheEngineSession implements ICacheEngine, ICacheEngineStat
{

}
```
#### Расположение `required_file`
Можно положить класс `CacheEngineSession.php` в папку `/local/php_interface/lib/cache/`.

#### Итоги
Файл настроек будет выглядеть примерно так:
```php
'cache' => 
  array (
    'value' => 
    array (
      'type' => array(
        'class_name' => 'CacheEngineSession',
        'required_file' => 'php_interface/lib/cache/CacheEngineSession.php',
         //'required_remote_file' => '', //Не требуется
         //'extension' => '' //Расширение не требуется
      ),
    ),
    'readonly' => false,
  ),
```
> Неиспользуемые ключи нужно неуказывать, так как внутри ядра идут проверки `isset`, которые приведут к неожиданным результатам
> - Примечание разработчика

Результатом правильного выполнения инструкции будет название `CacheEngineSession` в *Административная часть* -> *Настройки* -> *Панель производительности* -> *Вкладка Битрикс*.
<img src="http://dl3.joxi.net/drive/0014/0707/971459/160106/1c706c8b8d.png">

Сессия пользователя это хорошо, но практической ценности от неё никакой (в качестве кэша). Поэтому рассмотрим более практичный подход.

### Хранение кэша в shmop `CacheEngineShmop` (Разделяемая (shared) память).
В качестве примера, реализуем класс для хранения кэша в shared памяти unix. Метод и технология достаточно устаревшие.
```php

use \Bitrix\Main\Data\ICacheEngine;
use \Bitrix\Main\Data\ICacheEngineStat;
use \Bitrix\Main\Config\Configuration;

/**
 * Caching based on Unix Share Memory
 *
 * # ipcs -m
 * List all segments used
 *
 * # ipcs -lm
 * ------ Shared Memory Limits --------
 * max number of segments = 4096       <--- this is SHMMNI
 * max seg size (kbytes) = 67108864    <--- this is SHMMAX
 * max total shared memory (kbytes) = 17179869184<- this is SHMALL
 * min seg size (bytes) = 1
 *
 *
 */

class CacheEngineShmop implements ICacheEngine, ICacheEngineStat
{

}
```
#### Расположение `required_file`
Можно положить класс `CacheEngineShmop.php` в папку `/local/php_interface/lib/cache/`.

#### Итоги
Файл настроек будет выглядеть примерно так:
```php
'cache' => 
  array (
    'value' => 
    array (
      'type' => array(
        'class_name' => 'CacheEngineShmop',
        'required_file' => 'php_interface/lib/cache/CacheEngineShmop.php',
      ),
    ),
    'readonly' => false,
  ),
```
Результатом правильного выполнения инструкции будет название `CacheEngineShmop` в *Административная часть* -> *Настройки* -> *Панель производительности* -> *Вкладка Битрикс*.

## Ссылки по теме
- <a href="https://gist.github.com/SidiGi/3d59c415593549d73d6c" target="_blank">Подробнее о настройке кэширвоания (из коробки)</a>
- <a href="https://gist.github.com/SidiGi/f6ceccd9e7bdd1d5e12e" target="_blank">Подробнее о файле настроек</a>

### PHP
- <a href="http://php.net/manual/ru/book.shmop.php" target="_blank">Подробнее о управлении распределённой памятью</a>


## CacheEngineSession.php
```php
<?php

use \Bitrix\Main\Data\ICacheEngine;
use \Bitrix\Main\Data\ICacheEngineStat;
use \Bitrix\Main\Config\Configuration;

class CacheEngineSession implements ICacheEngine, ICacheEngineStat
{
    /**
     * @var string
     */
    private $sid = "";

    /**
     * Переменные для реализации методов из интерфейса ICacheEngineStat
     * @var bool
     */
    private $written = false;
    /**
     * @var bool
     */
    private $read = false;

    /**
     * CacheEngineSession constructor.
     */
    public function __construct()
    {
        $v = Configuration::getValue("cache");
        if ($v != null && isset($v["sid"]) && ($v["sid"] != ""))
            $this->sid = $v["sid"];
        else
            $this->sid = "BX";
    }

    /**
     * @return integer
     */
    public function getReadBytes()
    {
        return $this->read;
    }

    /**
     * @return integer
     */
    public function getWrittenBytes()
    {
        return $this->written;
    }

    /**
     * @return string
     */
    public function getCachePath()
    {
        return '';
    }

    /**
     * @return bool
     */
    public function isAvailable()
    {
        return $this->checkSession();
    }

    /**
     * @param $baseDir
     * @param bool|false $initDir
     * @param bool|false $filename
     */
    public function clean($baseDir, $initDir = false, $filename = false)
    {
        $this->checkSession();

        $this->sessionOperation($baseDir, $initDir, $filename, 'clean');
    }

    /**
     * @param $arAllVars
     * @param $baseDir
     * @param $initDir
     * @param $filename
     * @param $TTL
     * @return bool
     */
    public function read(&$arAllVars, $baseDir, $initDir, $filename, $TTL)
    {
        $this->checkSession();

        $arAllVars = $this->sessionOperation($baseDir, $initDir, $filename, 'read');

        if ($arAllVars) {
            $this->read = strlen($arAllVars);
            return true;
        } else {
            return false;
        }
    }

    /**
     * @param $arAllVars
     * @param $baseDir
     * @param $initDir
     * @param $filename
     * @param $TTL
     */
    public function write($arAllVars, $baseDir, $initDir, $filename, $TTL)
    {
        $this->checkSession();
        $this->sessionOperation($baseDir, $initDir, $filename, 'add', $arAllVars);
        if (isset($arAllVars)){
            $this->written = strlen($arAllVars);
        }

    }

    /**
     * @param $path
     * @return bool
     */
    public function isCacheExpired($path)
    {
        return false;
    }

    /**
     * @return bool
     */
    protected function checkSession()
    {
        if (session_status() == PHP_SESSION_NONE)
            session_start();

        return !(session_status() == PHP_SESSION_NONE);
    }

    /**
     * @return string
     */
    protected function getSID()
    {
        return (isset($this->sid) ? $this->sid : "default");
    }

    /**
     * @param $baseDir
     * @param $initDir
     * @param $filename
     * @param $operation
     * @param bool|false $data
     * @return bool
     */
    private function sessionOperation($baseDir, $initDir, $filename, $operation, $data = false){
        $baseDir = $baseDir . '/';
        $initDir = '/'. $initDir . '/';
        $filename = '/'. $filename;
        $path = explode('/', str_replace('//', '/', $baseDir . $initDir . $filename));
        trimArr($path);

        if (!is_array($path))
            $path[] = $path;

        $path = array_merge(['cache', $this->getSID() ], $path);

        $link = &$_SESSION;

        foreach($path as $index => $item){
            $lastItem = $item;
            if (!$path[$index + 1]) break;
            $link = &$link[$item];
        }

        if ($operation == 'add'){
            $link[$lastItem] = $data;
            return $link[$lastItem];
        }

        if ($operation == 'read')
            return $link[$lastItem];

        if ($operation == 'clean'){
            unset($link[$lastItem]);
            return true;
        }

        return false;

    }
}
```